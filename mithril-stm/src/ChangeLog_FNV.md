# Full Node Verifier Progress Log

## Questions
1. Is it OK for the `StmSigner` to generate `FullNodeSignature`?
2. What is the most efficient way to make `StmAggrSig` functions to depend on `FullNodeVerifier` functions?
3. Namings?: Include avk with the old scheme
4. Individual file?
5. Test cases?
6. Which traits to be derived?

## ToDo:
- [ ] Trait implementations
- [ ] Tests
- [ ] Documentation
- [ ] Test full protocol
- [ ] Benches
- [ ] Compatibility check with the rest of the project
- [ ] GH PR description update


## Progress
### 2023-05-24
* `FullNodeSigner`, its implementation and related functions are removed. 
  * `FullNodeSignature` is generated by the `StmSigner` with the function `generate_full_node_sig`.
  * `check_lottery` function is moved to `StmSigner` and it is used by both `sign()` and `generate_full_node_sig`.
    * `sign` runs with `msgp`, 
    * `generate_full_node_sig` runs with only `msg`.
* The struct `FullNodeVerifier` is added.
  * `collect_reg_parties`: Filters the eligible parties who have issued a signature by their indices.
  * `preliminary_verify`: It has all functionalities of `StmAggrSig::preliminary_verify` except from checking the 
    batch proof, since full node verifier does not need to check it.
  * `verify_full_node_signature`: 
    * Runs `collect_reg_parties` and `preliminary_verify`. 
    * Collects signatures and verification keys in vectors.
    * Verifies the aggregate.
    
### 2023-05-23
* First decision was to have a different rust file for FNV. However, there is some uncertainties about how to get AVK.
  So, for now the implementation is moved to `stm.rs`.
* **Update:** Full node verifier does not use merkle tree, commitment, and registration information. So, we will
  have `FullNodeSigner`, `FullNodeSignature` and their implementations. Stm signer and stm signature will depend on them
  respectively.

    * The struct `FullNodeSigner` is added, it does not include closed register.
    * The struct `FullNodeSignature` is added, it does not include signer index.

    * The implementation of `StmInitializer`:
        * `check_initializer()`: Checks whether initializer is actually registered and returns the index of the signer
          if registered.
        * `new_signer()`: Runs `check_initializer()`, if check is done, gets the index and
          returns the `StmSigner`.
        * `new_full_node_signer()`: Runs `check_initializer()`, if check is done, gets the index and returns
          the `FullNodeSigner`.

    * The implementation of `FullNodeSigner()`:
        * `check_lottery()`: Checks whether any of the indices won the lottery for given parameters, message, total
          stake, sigma and signer stake. Returns the winning indices.
        * `sign()`: Generates `sigma` for `msg` and `sk`. Calls `FullNodeSigner::check_lottery` if indices are not 
          empty, returns the `FullNodeSignature`.

    * The implementation of `StmSigner()`:
        * `sign()`: Computes `msgp` by concatenating commitment with message. Generates `sigma` for `msgp` and `sk`. 
          Calls `FullNodeSigner::check_lottery` if indices are not empty, returns the `StmSig`.

    * The implementation of `FullNodeSignature`:
        * `check_indices()`: Checks the indices of the `FullNodeSignature` for given total_stake, msg, parameters and
          signer stake.
        * `verify()`: Verifies sigma and checks the indices.
        * `from_stm_sig()`: Returns `FullNodeSignature` for given `StmSig`.

    * The implementation of `StmSig`:
        * `check_indices()`: Will be removed
        * `verify()`: Computes `msgp` by concatenating commitment with message. Verifies `sigma`, checks indices by 
          calling `FullNodeSignature::check_indices`.


## Method

### Full node verifier struct
```rust
/// FullNodeVerifier structure, that contains keys of all eligible signers.
pub struct FullNodeVerifier {
    /// Ordered list of registered parties.
    pub elligible_parties: Vec<RegParty>, // Maybe indexed HashMap
    /// Total stake of the registered parties.
    pub total_stake: Stake,
}
```
### Verification for a full node:
For each sig in in_sigs do:
- Check lottery
- Get PK from given index
- aggregate sigs to accumulator
- aggregate pks to accumulator
- verify aggregated sig wrt aggregated pk.